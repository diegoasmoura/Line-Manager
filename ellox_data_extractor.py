"""
Extrator de Dados da API Ellox
Este m√≥dulo extrai e armazena dados da API Ellox no banco Oracle
"""

import requests
import pandas as pd
from datetime import datetime
from database import get_database_connection
from ellox_api import get_default_api_client
from sqlalchemy import text, create_engine
import time
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ElloxDataExtractor:
    """Classe para extrair e armazenar dados da API Ellox"""
    
    def __init__(self):
        """Inicializa o extrator com cliente da API"""
        self.client = get_default_api_client()
        if not self.client.authenticated:
            raise Exception("Falha na autentica√ß√£o com a API Ellox")
        
        logger.info("‚úÖ Cliente API Ellox autenticado com sucesso")
    
    def create_tables(self):
        """Cria as tabelas necess√°rias no banco Oracle"""
        conn = get_database_connection()
        
        try:
            # Tabela de Terminais
            conn.execute(text("""
                CREATE TABLE LogTransp.F_ELLOX_TERMINALS (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    NOME VARCHAR2(200) NOT NULL,
                    CNPJ VARCHAR2(20) NOT NULL UNIQUE,
                    CIDADE VARCHAR2(100),
                    ATIVO CHAR(1) DEFAULT 'Y',
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    DATA_ATUALIZACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """))
            logger.info("‚úÖ Tabela F_ELLOX_TERMINALS criada")
            
            # Tabela de Navios
            conn.execute(text("""
                CREATE TABLE LogTransp.F_ELLOX_SHIPS (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    NOME VARCHAR2(200) NOT NULL,
                    TERMINAL_CNPJ VARCHAR2(20) NOT NULL,
                    CARRIER VARCHAR2(50),
                    IMO VARCHAR2(20),
                    MMSI VARCHAR2(20),
                    FLAG VARCHAR2(50),
                    ATIVO CHAR(1) DEFAULT 'Y',
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    DATA_ATUALIZACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT FK_SHIPS_TERMINAL FOREIGN KEY (TERMINAL_CNPJ) 
                        REFERENCES LogTransp.F_ELLOX_TERMINALS(CNPJ)
                )
            """))
            logger.info("‚úÖ Tabela F_ELLOX_SHIPS criada")
            
            # Tabela de Voyages
            conn.execute(text("""
                CREATE TABLE LogTransp.F_ELLOX_VOYAGES (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    SHIP_NAME VARCHAR2(200) NOT NULL,
                    TERMINAL_CNPJ VARCHAR2(20) NOT NULL,
                    VOYAGE_CODE VARCHAR2(50) NOT NULL,
                    CARRIER VARCHAR2(50),
                    STATUS VARCHAR2(50),
                    ETD DATE,
                    ETA DATE,
                    POL VARCHAR2(100),
                    POD VARCHAR2(100),
                    ATIVO CHAR(1) DEFAULT 'Y',
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    DATA_ATUALIZACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """))
            logger.info("‚úÖ Tabela F_ELLOX_VOYAGES criada")
            
            # Tabela de Carriers
            conn.execute(text("""
                CREATE TABLE LogTransp.F_ELLOX_CARRIERS (
                    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    NOME VARCHAR2(100) NOT NULL UNIQUE,
                    CODIGO VARCHAR2(20),
                    NOME_COMPLETO VARCHAR2(200),
                    ATIVO CHAR(1) DEFAULT 'Y',
                    DATA_CRIACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    DATA_ATUALIZACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """))
            logger.info("‚úÖ Tabela F_ELLOX_CARRIERS criada")
            
            # √çndices para performance
            conn.execute(text("CREATE INDEX IDX_SHIPS_NAME ON LogTransp.F_ELLOX_SHIPS(NOME)"))
            conn.execute(text("CREATE INDEX IDX_SHIPS_TERMINAL ON LogTransp.F_ELLOX_SHIPS(TERMINAL_CNPJ)"))
            conn.execute(text("CREATE INDEX IDX_VOYAGES_SHIP ON LogTransp.F_ELLOX_VOYAGES(SHIP_NAME)"))
            conn.execute(text("CREATE INDEX IDX_VOYAGES_CODE ON LogTransp.F_ELLOX_VOYAGES(VOYAGE_CODE)"))
            
            conn.commit()
            logger.info("‚úÖ Todas as tabelas e √≠ndices criados com sucesso")
            
        except Exception as e:
            if "name is already used" in str(e).lower() or "already exists" in str(e).lower():
                logger.info("‚ÑπÔ∏è Tabelas j√° existem, continuando...")
            else:
                logger.error(f"‚ùå Erro ao criar tabelas: {e}")
                raise
        finally:
            conn.close()
    
    def extract_terminals(self):
        """Extrai terminais da API e armazena no banco"""
        logger.info("üîÑ Extraindo terminais da API...")
        
        try:
            response = requests.get(
                f"{self.client.base_url}/api/terminals",
                headers=self.client.headers,
                timeout=30
            )
            
            if response.status_code != 200:
                raise Exception(f"Erro na API: {response.status_code} - {response.text}")
            
            terminals = response.json()
            logger.info(f"üìç {len(terminals)} terminais encontrados")
            
            # Preparar dados para inser√ß√£o
            terminals_data = []
            for terminal in terminals:
                if isinstance(terminal, dict):
                    terminals_data.append({
                        'nome': terminal.get('name', terminal.get('nome', 'N/A')),
                        'cnpj': terminal.get('cnpj', ''),
                        'cidade': terminal.get('city', terminal.get('cidade', 'N/A'))
                    })
            
            # Inserir no banco
            conn = get_database_connection()
            try:
                # Limpar dados existentes (primeiro navios, depois terminais)
                conn.execute(text("DELETE FROM LogTransp.F_ELLOX_SHIPS"))
                conn.execute(text("DELETE FROM LogTransp.F_ELLOX_VOYAGES"))
                conn.execute(text("DELETE FROM LogTransp.F_ELLOX_TERMINAL_MONITORINGS"))
                conn.execute(text("DELETE FROM LogTransp.F_ELLOX_TERMINALS"))
                
                # Inserir novos dados
                for terminal in terminals_data:
                    conn.execute(text("""
                        INSERT INTO LogTransp.F_ELLOX_TERMINALS (NOME, CNPJ, CIDADE)
                        VALUES (:nome, :cnpj, :cidade)
                    """), terminal)
                
                conn.commit()
                logger.info(f"‚úÖ {len(terminals_data)} terminais inseridos no banco")
                
            finally:
                conn.close()
                
            return terminals_data
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao extrair terminais: {e}")
            raise
    
    def extract_ships(self, terminals_data):
        """Extrai navios da API para cada terminal e armazena no banco"""
        logger.info("üîÑ Extraindo navios da API...")
        
        all_ships = []
        total_terminals = len(terminals_data)
        
        conn = get_database_connection()
        try:
            # Dados j√° foram limpos no extract_terminals()
            
            for i, terminal in enumerate(terminals_data, 1):
                cnpj = terminal['cnpj']
                nome_terminal = terminal['nome']
                
                logger.info(f"üö¢ Processando terminal {i}/{total_terminals}: {nome_terminal}")
                
                try:
                    response = requests.get(
                        f"{self.client.base_url}/api/ships",
                        params={'terminal': cnpj},
                        headers=self.client.headers,
                        timeout=15
                    )
                    
                    if response.status_code == 200:
                        ships = response.json()
                        
                        for ship in ships:
                            ship_name = ship if isinstance(ship, str) else ship.get('name', ship.get('nome', ''))
                            
                            if ship_name:
                                ship_data = {
                                    'nome': ship_name,
                                    'terminal_cnpj': cnpj,
                                    'carrier': self._identify_carrier_from_ship_name(ship_name)
                                }
                                
                                # Inserir no banco imediatamente
                                conn.execute(text("""
                                    INSERT INTO LogTransp.F_ELLOX_SHIPS (NOME, TERMINAL_CNPJ, CARRIER)
                                    VALUES (:nome, :terminal_cnpj, :carrier)
                                """), ship_data)
                                
                                all_ships.append(ship_data)
                        
                        logger.info(f"  ‚úÖ {len(ships)} navios encontrados em {nome_terminal}")
                    
                    else:
                        logger.warning(f"  ‚ö†Ô∏è Erro {response.status_code} para terminal {nome_terminal}")
                
                except requests.exceptions.Timeout:
                    logger.warning(f"  ‚è∞ Timeout para terminal {nome_terminal}")
                except Exception as e:
                    logger.warning(f"  ‚ùå Erro para terminal {nome_terminal}: {str(e)[:100]}")
                
                # Pequena pausa para n√£o sobrecarregar a API
                time.sleep(0.5)
            
            conn.commit()
            logger.info(f"‚úÖ {len(all_ships)} navios inseridos no banco")
            
        finally:
            conn.close()
        
        return all_ships
    
    def extract_voyages_sample(self, ships_sample=50):
        """Extrai uma amostra de voyages para n√£o sobrecarregar a API"""
        logger.info(f"üîÑ Extraindo amostra de {ships_sample} voyages...")
        
        conn = get_database_connection()
        try:
            # Pegar amostra de navios
            result = conn.execute(text(f"""
                SELECT NOME, TERMINAL_CNPJ, CARRIER 
                FROM LogTransp.F_ELLOX_SHIPS 
                WHERE ROWNUM <= {ships_sample}
                ORDER BY DBMS_RANDOM.VALUE
            """))
            
            ships = result.fetchall()
            
            # Dados j√° foram limpos no extract_terminals()
            
            all_voyages = []
            
            for i, ship in enumerate(ships, 1):
                ship_name, terminal_cnpj, carrier = ship
                
                logger.info(f"‚õµ Processando voyage {i}/{len(ships)}: {ship_name}")
                
                try:
                    response = requests.get(
                        f"{self.client.base_url}/api/voyages",
                        params={'ship': ship_name, 'terminal': terminal_cnpj},
                        headers=self.client.headers,
                        timeout=10
                    )
                    
                    if response.status_code == 200:
                        voyages = response.json()
                        
                        for voyage in voyages[:5]:  # M√°ximo 5 voyages por navio
                            voyage_code = voyage if isinstance(voyage, str) else voyage.get('voyage', voyage.get('codigo', ''))
                            
                            if voyage_code:
                                voyage_data = {
                                    'ship_name': ship_name,
                                    'terminal_cnpj': terminal_cnpj,
                                    'voyage_code': voyage_code,
                                    'carrier': carrier
                                }
                                
                                # Inserir no banco
                                conn.execute(text("""
                                    INSERT INTO LogTransp.F_ELLOX_VOYAGES (SHIP_NAME, TERMINAL_CNPJ, VOYAGE_CODE, CARRIER)
                                    VALUES (:ship_name, :terminal_cnpj, :voyage_code, :carrier)
                                """), voyage_data)
                                
                                all_voyages.append(voyage_data)
                        
                        logger.info(f"  ‚úÖ {len(voyages)} voyages encontrados")
                    
                except requests.exceptions.Timeout:
                    logger.warning(f"  ‚è∞ Timeout para {ship_name}")
                except Exception as e:
                    logger.warning(f"  ‚ùå Erro para {ship_name}: {str(e)[:100]}")
                
                time.sleep(0.3)  # Pausa menor
            
            conn.commit()
            logger.info(f"‚úÖ {len(all_voyages)} voyages inseridos no banco")
            
        finally:
            conn.close()
        
        return all_voyages
    
    def extract_carriers(self):
        """Insere lista de carriers suportados no banco"""
        logger.info("üîÑ Inserindo carriers suportados...")
        
        carriers_data = [
            {'nome': 'HAPAG-LLOYD', 'codigo': 'HAL', 'nome_completo': 'Hapag-Lloyd AG'},
            {'nome': 'MAERSK', 'codigo': 'MAEU', 'nome_completo': 'A.P. Moller-Maersk'},
            {'nome': 'MSC', 'codigo': 'MSCU', 'nome_completo': 'Mediterranean Shipping Company'},
            {'nome': 'CMA CGM', 'codigo': 'CMDU', 'nome_completo': 'CMA CGM Group'},
            {'nome': 'COSCO', 'codigo': 'COSU', 'nome_completo': 'COSCO Shipping Lines'},
            {'nome': 'EVERGREEN', 'codigo': 'EGLV', 'nome_completo': 'Evergreen Marine'},
            {'nome': 'OOCL', 'codigo': 'OOLU', 'nome_completo': 'Orient Overseas Container Line'},
            {'nome': 'PIL', 'codigo': 'PILU', 'nome_completo': 'Pacific International Lines'}
        ]
        
        conn = get_database_connection()
        try:
            # Limpar dados existentes
            conn.execute(text("DELETE FROM LogTransp.F_ELLOX_CARRIERS"))
            
            # Inserir carriers
            for carrier in carriers_data:
                conn.execute(text("""
                    INSERT INTO LogTransp.F_ELLOX_CARRIERS (NOME, CODIGO, NOME_COMPLETO)
                    VALUES (:nome, :codigo, :nome_completo)
                """), carrier)
            
            conn.commit()
            logger.info(f"‚úÖ {len(carriers_data)} carriers inseridos no banco")
            
        finally:
            conn.close()
        
        return carriers_data
    
    def _identify_carrier_from_ship_name(self, ship_name):
        """Identifica o carrier baseado no nome do navio"""
        ship_name_upper = ship_name.upper()
        
        if 'MAERSK' in ship_name_upper:
            return 'MAERSK'
        elif 'CMA CGM' in ship_name_upper:
            return 'CMA CGM'
        elif 'MSC' in ship_name_upper:
            return 'MSC'
        elif 'COSCO' in ship_name_upper or 'KOTA' in ship_name_upper:
            return 'COSCO'
        elif 'HAPAG' in ship_name_upper or 'CAP ' in ship_name_upper or 'CAPE ' in ship_name_upper:
            return 'HAPAG-LLOYD'
        elif 'EVER' in ship_name_upper:
            return 'EVERGREEN'
        elif 'PIL' in ship_name_upper:
            return 'PIL'
        else:
            return 'OUTROS'
    
    def run_full_extraction(self, ships_sample=100):
        """Executa extra√ß√£o completa de todos os dados"""
        logger.info("üöÄ Iniciando extra√ß√£o completa dos dados da API Ellox")
        
        start_time = datetime.now()
        
        try:
            # 1. Criar tabelas
            logger.info("1Ô∏è‚É£ Criando tabelas...")
            self.create_tables()
            
            # 2. Extrair carriers
            logger.info("2Ô∏è‚É£ Extraindo carriers...")
            carriers = self.extract_carriers()
            
            # 3. Extrair terminais
            logger.info("3Ô∏è‚É£ Extraindo terminais...")
            terminals = self.extract_terminals()
            
            # 4. Extrair navios
            logger.info("4Ô∏è‚É£ Extraindo navios...")
            ships = self.extract_ships(terminals)
            
            # 5. Extrair amostra de voyages
            logger.info("5Ô∏è‚É£ Extraindo voyages...")
            voyages = self.extract_voyages_sample(ships_sample)
            
            # Resumo final
            end_time = datetime.now()
            duration = end_time - start_time
            
            logger.info("üéâ Extra√ß√£o completa finalizada!")
            logger.info(f"üìä Resumo:")
            logger.info(f"  ‚Ä¢ Carriers: {len(carriers)}")
            logger.info(f"  ‚Ä¢ Terminais: {len(terminals)}")
            logger.info(f"  ‚Ä¢ Navios: {len(ships)}")
            logger.info(f"  ‚Ä¢ Voyages: {len(voyages)}")
            logger.info(f"  ‚Ä¢ Tempo total: {duration}")
            
            return {
                'carriers': len(carriers),
                'terminals': len(terminals),
                'ships': len(ships),
                'voyages': len(voyages),
                'duration': str(duration)
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o: {e}")
            raise

def main():
    """Fun√ß√£o principal para executar a extra√ß√£o"""
    try:
        extractor = ElloxDataExtractor()
        result = extractor.run_full_extraction(ships_sample=50)  # Amostra menor para teste
        
        print("\n" + "="*60)
        print("üéâ EXTRA√á√ÉO CONCLU√çDA COM SUCESSO!")
        print("="*60)
        print(f"üìä Dados extra√≠dos:")
        print(f"  ‚Ä¢ Carriers: {result['carriers']}")
        print(f"  ‚Ä¢ Terminais: {result['terminals']}")
        print(f"  ‚Ä¢ Navios: {result['ships']}")
        print(f"  ‚Ä¢ Voyages: {result['voyages']}")
        print(f"  ‚Ä¢ Tempo total: {result['duration']}")
        print("="*60)
        
    except Exception as e:
        print(f"‚ùå Erro na execu√ß√£o: {e}")
        return False
    
    return True

if __name__ == "__main__":
    main()
