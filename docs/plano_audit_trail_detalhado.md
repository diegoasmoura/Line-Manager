# Plano detalhado: Login, autoria (USER_LOGIN) e trilha de mudanças (Audit Trail)


  Objetivo Final: Implementar um sistema robusto de autenticação de usuário e uma 
  trilha de auditoria centralizada, substituindo os mecanismos de log antigos e 
  fragmentados por uma arquitetura moderna, explícita e mais fácil de manter.



## Premissas e convenções

- Todos os objetos serão criados no schema `LogTransp` (ajuste se usar outro schema).
- Padrão de autoria do operador (usuário logado no app): `USER_LOGIN` (VARCHAR2(150 CHAR)).
- Não usaremos `USER_LOGIN_LAST_UPDATE` neste momento. O "último a alterar" será consultado na trilha.
- Separação de responsabilidades:
  - `F_CON_CHANGE_LOG`: trilha técnica, campo‑a‑campo, imutável.
  - `F_CON_RETURN_CARRIERS`: eventos de negócio (ajustes, splits, aprovações) com justificativas.
  - `F_CON_VOYAGE_MANUAL_UPDATES`: será descontinuada (substituída por registros na `F_CON_CHANGE_LOG`).

---

## Fase 1 — DDL Oracle (com comentários minuciosos)

### 1.1 Criar tabela de trilha técnica (campo‑a‑campo)

Use este script completo (com comentários nos campos):

```sql
-- Tabela central de trilha técnica de alterações campo-a-campo
CREATE TABLE LogTransp.F_CON_CHANGE_LOG (
  ID                NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  FAROL_REFERENCE   VARCHAR2(50 CHAR)    NOT NULL,
  TABLE_NAME        VARCHAR2(60 CHAR)    NOT NULL,
  COLUMN_NAME       VARCHAR2(80 CHAR)    NOT NULL,
  OLD_VALUE         VARCHAR2(1000 CHAR),
  NEW_VALUE         VARCHAR2(1000 CHAR),
  USER_LOGIN        VARCHAR2(150 CHAR)   NOT NULL,
  CHANGE_SOURCE     VARCHAR2(40 CHAR),
  CHANGE_TYPE       VARCHAR2(10 CHAR),
  ADJUSTMENT_ID     VARCHAR2(80 CHAR),
  RELATED_REFERENCE VARCHAR2(80 CHAR),
  CHANGE_AT         TIMESTAMP(6) DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE LogTransp.F_CON_CHANGE_LOG IS 'Trilha técnica imutável: 1 linha por coluna alterada, com quem/onde/quando.';

COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.ID                IS 'Chave técnica (auto-incremento).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.FAROL_REFERENCE   IS 'Referência Farol associada à alteração.';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.TABLE_NAME        IS 'Nome da tabela de negócio afetada (ex.: F_CON_SALES_BOOKING_DATA).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.COLUMN_NAME       IS 'Nome da coluna alterada na tabela de negócio.';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.OLD_VALUE         IS 'Valor anterior (normalizado como texto).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.NEW_VALUE         IS 'Novo valor (normalizado como texto).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.USER_LOGIN        IS 'Login do usuário do app que realizou a alteração.';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.CHANGE_SOURCE     IS 'Origem da mudança (booking_new, tracking, history, attachments, shipments.py etc.).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.CHANGE_TYPE       IS 'Tipo de mudança: CREATE/UPDATE/DELETE (ou outro se necessário).';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.ADJUSTMENT_ID     IS 'Ajuste associado (quando aplicável), para correlação com retornos/aprovações.';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.RELATED_REFERENCE IS 'Referência relacionada (ex.: linked reference) quando aplicável.';
COMMENT ON COLUMN LogTransp.F_CON_CHANGE_LOG.CHANGE_AT         IS 'Timestamp da auditoria (fuso do banco).';

-- Índice para acesso rápido por referência e tempo
CREATE INDEX IX_CHANGELOG_REF_DATE 
  ON LogTransp.F_CON_CHANGE_LOG(FAROL_REFERENCE, CHANGE_AT DESC);
```

Boas práticas:

- Formato de datas em OLD_VALUE/NEW_VALUE: normalizar na aplicação como `YYYY-MM-DD HH24:MI:SS` (texto), quando for data/hora.
- `NULL` deve ser gravado como texto vazio ou a string literal 'NULL'? Sugestão: gravar `NULL` como string literal 'NULL' para diferenciar de vazio.

---

### 1.2 Adicionar autoria por etapa na tabela principal

Registrar quem criou em Sales e quem criou o Booking. Apenas criação (não substitui os donos de negócio `S_SALE_OWNER`/`B_BOOKING_OWNER`).

```sql
ALTER TABLE LogTransp.F_CON_SALES_BOOKING_DATA ADD (
  USER_LOGIN_SALES_CREATED   VARCHAR2(150 CHAR),
  USER_LOGIN_BOOKING_CREATED VARCHAR2(150 CHAR)
);

COMMENT ON COLUMN LogTransp.F_CON_SALES_BOOKING_DATA.USER_LOGIN_SALES_CREATED 
  IS 'Login do usuário do app que criou o registro na etapa Sales (shipments_new).';
COMMENT ON COLUMN LogTransp.F_CON_SALES_BOOKING_DATA.USER_LOGIN_BOOKING_CREATED 
  IS 'Login do usuário do app que criou a etapa Booking (booking_new). Primeira vez apenas.';
```

Regra futura: `USER_LOGIN_BOOKING_CREATED` deve ser populado apenas se ainda estiver `NULL`, para não sobrescrever a autoria original da criação do Booking.

---

### 1.3 Justificativas de Ajustes/Splits

Campos de justificativa (AREA, REQUEST_REASON, ADJUSTMENTS_OWNER, COMMENTS) são armazenados em `F_CON_RETURN_CARRIERS`:
- Para cada ajuste/split criado, as justificativas são gravadas e preservadas mesmo após aprovações subsequentes
- Histórico campo-a-campo em `F_CON_CHANGE_LOG` (via `audit_change`)
- Visualização unificada em `V_FAROL_AUDIT_TRAIL` e aba "Audit Trail"

---

### 1.4 View unificada para a UI

Crie uma visão que una os eventos de negócio e as alterações técnicas em um feed único para a interface.

```sql
CREATE OR REPLACE VIEW LogTransp.V_FAROL_AUDIT_TRAIL AS
SELECT 
  'ADJUSTMENT' AS EVENT_KIND,
  FAROL_REFERENCE,
  CAST(NULL AS VARCHAR2(60))  AS TABLE_NAME,
  CAST(NULL AS VARCHAR2(80))  AS COLUMN_NAME,
  CAST(NULL AS VARCHAR2(1000)) AS OLD_VALUE,
  CAST(NULL AS VARCHAR2(1000)) AS NEW_VALUE,
  USER_LOGIN,
  P_STATUS     AS CHANGE_SOURCE,
  'UPDATE'     AS CHANGE_TYPE,
  ADJUSTMENT_ID,
  LINKED_REFERENCE AS RELATED_REFERENCE,
  ROW_INSERTED_DATE AS CHANGE_AT
FROM LogTransp.F_CON_RETURN_CARRIERS
UNION ALL
SELECT 
  'CHANGE' AS EVENT_KIND,
  FAROL_REFERENCE,
  TABLE_NAME,
  COLUMN_NAME,
  OLD_VALUE,
  NEW_VALUE,
  USER_LOGIN,
  CHANGE_SOURCE,
  CHANGE_TYPE,
  ADJUSTMENT_ID,
  RELATED_REFERENCE,
  CHANGE_AT
FROM LogTransp.F_CON_CHANGE_LOG;

COMMENT ON VIEW LogTransp.V_FAROL_AUDIT_TRAIL 
  IS 'Feed unificado: eventos de negócio (ajustes) e alterações técnicas campo-a-campo.';
```

Se o volume crescer, considere uma visão materializada (e agendamento de refresh).

---

## Fase 2 — Backend (database.py): utilitários e auditoria

### 2.1 Função para obter o usuário logado

```python
# database.py

def get_current_user_login() -> str:
    """Obtém o usuário logado no app; fallback para variável de ambiente ou 'system'."""
    try:
        import streamlit as st
        u = st.session_state.get("current_user")
        if u and str(u).strip():
            return str(u)[:150]
    except Exception:
        pass
    import os
    return (os.getenv("USER") or "system")[:150]
```

### 2.2 Função helper de auditoria

```python
# database.py
from sqlalchemy import text

ISO_FMT = "%Y-%m-%d %H:%M:%S"  # para normalizar datas em texto

def _normalize_value_for_log(value):
    """Converte diferentes tipos (None/NaT/datetime/number) para texto estável."""
    try:
        import pandas as pd
        if value is None or (hasattr(pd, 'isna') and pd.isna(value)):
            return 'NULL'
        # pandas.Timestamp ou datetime
        if hasattr(value, 'to_pydatetime'):
            value = value.to_pydatetime()
        import datetime as _dt
        if isinstance(value, (_dt.datetime,)):
            return value.strftime(ISO_FMT)
        if isinstance(value, (_dt.date,)):
            return f"{value.strftime('%Y-%m-%d')} 00:00:00"
        return str(value)[:1000]
    except Exception:
        return str(value)[:1000] if value is not None else 'NULL'


def audit_change(conn, farol_ref: str, table: str, column: str,
                 old, new, source: str,
                 change_type: str = 'UPDATE',
                 user: str | None = None,
                 adjustment_id: str | None = None,
                 related_ref: str | None = None) -> None:
    """Registra 1 linha por coluna alterada na F_CON_CHANGE_LOG.
    Deve ser chamado dentro da mesma transação do UPDATE/INSERT.
    """
    old_str = _normalize_value_for_log(old)
    new_str = _normalize_value_for_log(new)
    if old_str == new_str:
        return
    user_login = (user or get_current_user_login())[:150]
    conn.execute(text(
        """
        INSERT INTO LogTransp.F_CON_CHANGE_LOG
          (FAROL_REFERENCE, TABLE_NAME, COLUMN_NAME, OLD_VALUE, NEW_VALUE,
           USER_LOGIN, CHANGE_SOURCE, CHANGE_TYPE, ADJUSTMENT_ID, RELATED_REFERENCE)
        VALUES (:fr, :tbl, :col, :old, :new, :user, :src, :type, :adj, :rel)
        """
    ), {
        "fr": farol_ref, "tbl": table, "col": column,
        "old": old_str, "new": new_str,
        "user": user_login, "src": source, "type": change_type,
        "adj": adjustment_id, "rel": related_ref,
    })
```

Boas práticas:

- Sempre chamar `audit_change` dentro de `with conn.begin():` para garantir atomicidade com o UPDATE/INSERT.
- Converter previamente valores DATE (colunas de destino no DB com DATE) para `.date()` no momento do UPDATE para manter coerência entre persistido e auditado.

---

## Fase 3 — Backend: integrar a auditoria nos fluxos

A) `shipments_new.py` (criação Sales)

- No INSERT da `F_CON_SALES_BOOKING_DATA`, preencher `USER_LOGIN_SALES_CREATED = get_current_user_login()`.
- Não precisa trilha campo-a-campo nessa criação (opcionalmente, auditar um `CHANGE_TYPE='CREATE'` agregando colunas críticas, mas não é necessário agora).

B) `booking_new.py` (edição DTHC/Week/Quantity/POL/POD/Final Destination)

- Antes do UPDATE: selecionar os valores atuais destas colunas da `F_CON_SALES_BOOKING_DATA`.
- Comparar com os novos valores.
- Para cada coluna alterada: chamar `audit_change(conn, farol_ref, 'F_CON_SALES_BOOKING_DATA', <coluna>, old, new, 'booking_new', 'UPDATE')`.
- Executar o UPDATE.
- Preencher `USER_LOGIN_BOOKING_CREATED` somente se for a primeira criação do Booking (campo ainda `NULL`).

C) `tracking.py` (edição de datas de voyage)

- Já existe o dicionário de `changes`. Para cada entrada que mapeia em `F_CON_SALES_BOOKING_DATA`, chamar `audit_change(..., 'tracking', 'UPDATE')` antes do UPDATE.
- Converter datetimes de destino ETA/ATA para `.date()` antes de persistir e auditar.

D) `history.py` (aprovação de PDF → atualizações na principal)

- Nas rotinas que atualizam campos em `F_CON_SALES_BOOKING_DATA` após aprovação, seguir o padrão "Ler → Auditar → Atualizar" por coluna.
- Se houver `adjustment_id`/`related_reference`, informar nos parâmetros do `audit_change`.

E) Anexos (upload/delete em `F_CON_ANEXOS`)

- Ao salvar um anexo: auditar como `COLUMN_NAME='ATTACHMENT'`, `CHANGE_TYPE='CREATE'`, `CHANGE_SOURCE='attachments'`, `OLD_VALUE='NULL'`, `NEW_VALUE='<file_name.ext>'`.
- Ao marcar exclusão: `CHANGE_TYPE='DELETE'`, `OLD_VALUE='<file_name.ext>'`, `NEW_VALUE='NULL'`.

F) Descontinuar `F_CON_VOYAGE_MANUAL_UPDATES`

- Parar qualquer `INSERT` nela. Toda alteração manual de voyage será registrada em `F_CON_CHANGE_LOG` (source `tracking` ou `history`).

---

## Fase 4 — Frontend: login mínimo e nova aba no History

### 4.1 Login mínimo (`auth/login.py`)

- Form simples com usuário/senha (placeholder) que grava `st.session_state.current_user`.
- No futuro: hash/expiração.

### 4.2 Guard no `app.py`

- Antes de renderizar o app, se `current_user` não existir, exibir `show_login_form()`.

### 4.3 Nova aba "Audit Trail" no `history.py`

- Consultar `SELECT * FROM LogTransp.V_FAROL_AUDIT_TRAIL WHERE FAROL_REFERENCE = :ref ORDER BY CHANGE_AT DESC`.
- Exibir colunas: Data (CHANGE_AT), Usuário (USER_LOGIN), Origem (CHANGE_SOURCE), Tipo (CHANGE_TYPE), Tabela, Coluna, De/Para, Adjustment ID, Related Reference.
- Filtros: por Origem/Coluna/Tipo; opção "Somente última alteração por coluna" (pode ser feito em pandas).
- Formatar datas no fuso do Brasil (você já possui helpers).

---

## Fase 5 — Ativação e limpeza

1) Executar todos os DDLs (Fase 1).

2) Deploy do backend com utilitários (Fase 2) e integrações (Fase 3).

3) Deploy do frontend (login e aba "Audit Trail").

4) Testar cenários ponta a ponta (ver "Testes" abaixo).

5) Após validar:

   - Remover trigger/procedure antigas de ajustes, se existirem:
```sql
DROP TRIGGER LogTransp.Trigger_CON_Adjustments_Log;
DROP PROCEDURE LogTransp.PRC_Update_CON_Atualizacao_Tabelas_NEW_Trigger;
```

   - Descontinuar `F_CON_VOYAGE_MANUAL_UPDATES` (opcionalmente `DROP TABLE` ou manter somente leitura):
```sql
DROP TABLE LogTransp.F_CON_VOYAGE_MANUAL_UPDATES;
```


---

## Testes recomendados (passo a passo)

1) Login: efetuar login e verificar `st.session_state.current_user`.

2) Shipments New: criar um registro; conferir `USER_LOGIN_SALES_CREATED` na principal.

3) Booking New: alterar DTHC/Week/Quantity/POL/POD/Final Destination; verificar linhas em `F_CON_CHANGE_LOG` e dados atualizados.

4) Tracking: modificar datas; conferir atualizações + trilha.

5) History (aprovação de PDF): aprovar; conferir mudanças e trilha com `ADJUSTMENT_ID`.

6) Anexos: upload e delete; conferir trilha.

7) Aba "Audit Trail": visualizar feed unificado por referência.

---

## Consultas úteis

- Último responsável por alterar qualquer coisa em uma referência:
```sql
SELECT USER_LOGIN, CHANGE_AT
FROM LogTransp.F_CON_CHANGE_LOG
WHERE FAROL_REFERENCE = :ref
ORDER BY CHANGE_AT DESC
FETCH FIRST 1 ROWS ONLY;
```

- Último responsável a alterar um conjunto específico de colunas:
```sql
SELECT COLUMN_NAME, USER_LOGIN, CHANGE_AT
FROM LogTransp.F_CON_CHANGE_LOG
WHERE FAROL_REFERENCE = :ref
  AND COLUMN_NAME IN ('S_DTHC_PREPAID','S_REQUESTED_SHIPMENT_WEEK','S_QUANTITY_OF_CONTAINERS',
                      'S_PORT_OF_LOADING_POL','S_PORT_OF_DELIVERY_POD','S_FINAL_DESTINATION')
QUALIFY ROW_NUMBER() OVER (PARTITION BY COLUMN_NAME ORDER BY CHANGE_AT DESC) = 1; -- se tiver Oracle 23c; senão use subquery
```


---

## Checklist de execução (ordem sugerida)

1) Executar DDLs: 1.1, 1.2, 1.3 (opcional), 1.4.

2) Implementar `get_current_user_login` e `audit_change` no `database.py`.

3) Ligar auditoria em booking_new, tracking, history, anexos; setar autorias de criação em Sales/Booking.

4) Criar login mínimo e guard no app.

5) Implementar a aba "Audit Trail".

6) Testar todos os fluxos.

7) Remover trigger/procedure antigas e descontinuar `F_CON_VOYAGE_MANUAL_UPDATES`.

---

## Observações finais

- Tamanhos sugeridos: `USER_LOGIN` 150 CHAR; OLD/NEW 1000 CHAR (cobre textos e datas normalizadas).
- Consistência de tipos: datas no negócio continuam com seus tipos corretos; somente no log convertemos para texto ISO.
- Performance: o índice por (FAROL_REFERENCE, CHANGE_AT) atende as telas por referência; adicione índices por (TABLE_NAME, COLUMN_NAME) se filtrar muito por coluna.

### To-dos

- [x] Adicionar USER_LOGIN_* em F_CON_SALES_BOOKING_DATA
- [x] Migrar justificativas para F_CON_RETURN_CARRIERS
- [x] Criar tabela F_CON_CHANGE_LOG e índice
- [x] Implementar get_current_user_login e audit_change helper
- [x] Auditar updates do booking_new em update_booking_data_by_farol_reference
- [x] Auditar updates do tracking em update_booking_from_voyage
- [x] Auditar updates durante aprovações no history
- [x] Auditar updates do shipments.py (correção de persistência implementada)
- [ ] Auditar inclusão/remoção de anexos
- [ ] Implementar tela de login e session_state.current_user
- [ ] Criar nova aba Audit Trail em history.py

### ✅ Correção de Persistência Implementada (Janeiro 2025)

**Problema Resolvido**: O sistema de auditoria estava funcionando corretamente, mas as alterações feitas no `shipments.py` não eram persistidas na tabela principal `F_CON_SALES_BOOKING_DATA`.

**Solução Implementada**:
- ✅ Função `update_field_in_sales_booking_data()` para persistência de alterações
- ✅ Mapeamento correto de aliases SQL para colunas do banco de dados
- ✅ Conversão inteligente de nomes amigáveis para nomes técnicos
- ✅ Tratamento robusto de tipos de dados especiais

**Resultado**: O sistema agora persiste corretamente todas as alterações feitas na interface, mantendo a auditoria completa em `F_CON_CHANGE_LOG` e aplicando as mudanças na tabela principal.
